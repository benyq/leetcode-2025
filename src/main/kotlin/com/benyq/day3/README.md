回溯算法有点难哦。。。  
回溯是一种暴力穷解法
```kotlin
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
q77中使用startIndex跳过已经处理过的节点，优化。  
q216与q77没有什么大的区别，再加一个数值相等的判断条件即可  
q51是N皇后问题，这个就是经典的回溯问题，完全符合回溯的代码框架。
除了回溯，是否可以放置皇后的判断也是简化的  
